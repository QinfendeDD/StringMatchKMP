字符串匹配算法理解（从BF算法到KMP算法）
===========
* 暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法
* KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。
****** 

KMP算法是对BF算法进行改进的一种算法，但是如果直接去看KMP算法的话会很难理解（至少我看了几遍没看懂:smile:），我尝试着从BF算法优化过程去理解KMP算法，就会轻松很多。让我们一起开始吧。

* 先看看BF算法的匹配过程，目标串S["**BBCDABCDAACDAAAABCDAADE**"],模式串T["**ABCDAAD**"]


![][bf]

* BF算法代码
```cpp
int index_bf(char *s, char *t)
{
	int i = 0;
	int j = 0;
	while (s[i] != '\0')
	{
		while (*(t + j) != '\0' && *(s + i + j) != '\0')
		{
			if (*(t + j) != *(s + i + j))
				break;
			j++;
		}
		if (*(t + j) == '\0')
		{
			return i;
		}
		i++;
		j = 0;
	}
	return -1;
}
```

在图中，第5次匹配时一直匹配到字符'D'才失败，前面6个字符匹配成功，进行第6次匹配时，从目标串S加1字符与模式串T第1个字符重头进行匹配，这样效率太低了。
我们知道一次正确的匹配肯定是在目标串S中以模式串T首字符'A'开始的（如第5次和第9次匹配），因此*如果我们在每次匹配的过程中能够在目标串S中找到下一个模式串T首字符'A'位置的话，就可以直接从当前比较位置跳到下一个'A'位置进行继续匹配（如图中第5次匹配可以直接跳到第9次匹配），那么就可以省去很多不必要的匹配了。* 我们以此思路来进行第一次优化，我们观察第5次匹配过程，在'D'字符匹配失败时，前面匹配过的串"ABCDAA"，在目标串和模式串中是一样的，我们可以通过模式串T中第2个'A'的位置，来计算出目标串第2个'A'的位置，这样我们就可以直接跳到第9次比较了。

### BF算法第一次优化
在一次匹配中，目标串S从i位置与模式串T0（0为开始位置）位置开始重头匹配，在T的j位置失败，如果我们能知道在j位置失败时，T中已经匹配的串中下一个首字符出现的位置话，就可以直接跳到下一次首字符位置继续匹配啦。现在对模式串T设计一个数组 **int next[]**,数组长度与模式串T长度一致，数组j下标处存储着**模式串T的0到j-1子串第2次出现首字母位置（第一次就是首字母0处）**。上图第5次匹配，在模式串T j=6 处失败，模式串T 0到j-1=6的子串（"ABCDAA"）中第2次出现'A'的位置为4，子串中没有再次出现首字符表示-1。

模式串T和next数组

 0 |1 |2 |3 |4 |5 |6 |
:----: | :----:|:----:|:----:|:----:|:----:|:----:|
A  | B |C |D |A |A |D |
-1  | -1 |-1 |-1 |-1 |4 |4 |

* next数组算法
```cpp
void next_1(char pattern[], int next[], int n)
{
	int i = 0; //首字符位置
	int j = 1; //匹配失败的位置

	next[0] = -1;
	next[1] = -1;

	j = 2;
	for (; j < n;j++)
	{
		next[j] = -1;
		for (int k = 1; k < j;k++)
		{
			if (pattern[i] == pattern[k])
			{
				next[j] = k;
				break;
			}
		}
	}
}
```
* 利用该next数组对BF算法进行第1次优化
```cpp
int index_bf_1(char *s, char *t, int* n, int size)
{
	int i = 0;
	int j = 0;
	next_1(t, n, size);

	while (s[i] != '\0')
	{
		while (*(t + j) != '\0' && *(s + i + j) != '\0')
		{
			if (*(t + j) != *(s + i + j))
				break;
			j++;
		}
		if (*(t + j) == '\0')
		{
			return i;
		}
		
		if (n[j] == -1)
		{
			i++;
		}
		else
		{
			i += n[j];
		}

		//i++;
		j = 0;
	}
	return -1;
}
```
_利用该算法可以直接从最初BF算法第5次匹配直接跳到第9次匹配，下图_

![][bf1]

### BF算法第二次优化
经过第一次优化后，我们从原来的第5次匹配跳到第9次匹配，我们发现第10次匹配也是在第5次匹配的子串中进行，能不能从第5次直接跳到第10次匹配呢？
如果要直接跳到第10次比较，则在必须保证跳到第10次以后，在改位置之前的模式串字符与目标串字符都相等，为了实现这个目的，我们来重新设计next数组**int next[]**,数组长度与模式串T长度一致，数组j下标处存储着**模式串T的0到j-1子串从再次出现首字符位置（第一次就是首字符0处）开始一直到j之前与首字符有多少个连续相同的字符**，对于模式串"ABCDAAD",在j=3，子串（0-j-1）"ABC"没有再次出现首字符所以为next[3]=0。j=5,子串"ABCDA",再次出现了首字符，在5位置之前连续相等的也只有1个字符，故next[5]=1。j=6，子串"ABCDAA"，再次出现首字符是在4下标，但是4-5，"AA",与0-1，"AB"没有连续相同，因此需要再看下一个首字符出现位置5，在6之前没有其他字符，所以next[6]=1。我们通过j-next[j]就可以知道下一次有效的首字符位置了。


模式串T和新next数组

 0 |1 |2 |3 |4 |5 |6 |
:----: | :----:|:----:|:----:|:----:|:----:|:----:|
A  | B |C |D |A |A |D |
0 |0 |0 |0 |0 |1 |1 |

* 新next数组算法
```cpp
void next_2(char pattern[], int next[], int n)
{
	int i = 0; //首字符
	int j = 1; //匹配失败的位置

	next[0] = 0;
	next[1] = 0;

	j = 2;
	for (; j < n; j++)
	{
		int num = 0;
		for (int k = 1; k < j; k++)
		{
			if (pattern[i] == pattern[k])
			{
				i++;
				num++;
			}
			else
			{
				num = 0;
				i = 0;

				if (pattern[i] == pattern[k])
				{
					i++;
					num++;
				}
			}
		}
		next[j] = num;
		i = 0;
	}
}
```

* 利用新next数组改进bf算法
```cpp
int index_bf_2(char *s, char *t, int *n, int size, int index)
{
	int i = index;
	int j = 0;
	next_2(t, n, size);

	while (s[i] != '\0')
	{
		while (*(t + j) != '\0' && *(s + i + j) != '\0')
		{
			if (*(t + j) != *(s + i + j))
				break;
			j++;
		}

		if (*(t + j) == '\0')
		{
			return i;
		}

		if (n[j] == 0)
		{
			i += j==0?1:j;
			j = 0;
		}
		else
		{
			i += j - n[j];
			j = n[j];
		}

		//i++;
		//j = 0;
	}
	return -1;
}
```
_利用该算法可以直接从最初BF算法第5次匹配直接跳到第10次匹配，下图_

![][bf2]

* 通过加入了这个next数组后，我们匹配过程中对目标串S比较的位置一直是递增的，没有进行回溯，现在的BF算法就可以称为KMP算法啦。KMP算是对BF算法的改进，KMP算法有怎么改进呢？基本上对KMP算法改进，也就是对next函数进行优化。

### next函数的优化

对next数组优化，我们需要充分理解next数组每个下标j对应值的含义，下面我们利用next数组的值来进行优化。

```cpp
void next_3(char pattern[], int next[], int n)
{
	int i = 0; //首字符
	int j = 1; //匹配失败的位置

	next[0] = 0;
	next[1] = 0;

	j = 2;
	for (; j < n; j++)
	{
		int num = 0;
		i = next[j - 1];
		for (int k = 1+next[j-1]; k < j; k++)
		{
			if (pattern[i] == pattern[k])
			{
				i++;
				num++;
			}
			else
			{
				num = 0;
				i = 0;

				if (pattern[i] == pattern[k])
				{
					i++;
					num++;
				}
			}
		}

		next[j] = num;
		//i = 0;
	}
}
```


--------------------------------
[bf]:/StringMatch/img/BF.png "BF算法图示"
[bf1]:/StringMatch/img/BF_1.png "BF算法图示"
[bf2]:/StringMatch/img/BF_2.png "BF算法图示"
